// https://uk.javascript.info/ifelse     -----  інструкція if

// ======== Розгалуження =======

// if перевірка віку
// function checkAge(age) {     ----- оголошена функція перевірка в дужках чого саме, віку
//   if (age >= 18) {     ------   оголошена умова при якій буде видавати текст нижче
//     return "You are an adult";     ----   текст який випадає при виконаній умові вік 18 і більше років.
//   }
// }

// Функція відповіді якщо товару менше в наявності ніж в замовленні
// function checkStorage(available, ordered) {      ---    оголошено функцію перевірки відповідності (наявність, к-ть в замовленні)
//   if (available > ordered) {          -----    оголошено правило наявність більше ніж в замовленні
//     return "Order is processed, our manager will contact you"     --- видає повідомлення якщо правило виконане правильно і замовлення не перевищує наявність
//   } else {             -----    оголошує другу відповідь у випадку не дотримання правила, к-ть в замовленні більше ніж наявність
//     return "Not enough goods in stock!"    ----   видає повідомлення при порушенні правила
//   }
// }

// Функція перевірки корзини
// function checkStorage(available, ordered) {    -----    оголошення функції перевірки відповідності наявність - замовлення
// if (ordered === 0) {      ------    перевірка корзини на наявність товару
//   return "There are no products in the order!";    ----    виводить повідомлення якщо в корзині немає товару
// } else if (ordered > available) {       ------    вказує на те, що сума товару в корзині більша за наявність в магазині
// return "Your order is too large, there are not enough items in stock!";     -----   виводить повідомлення при перевищенні кількості перед наявністю
// } else if (ordered <= available) {      ------    вказує на те, що к-ть товару в корзині відповідає або = к-ті в наявності
//   return "The order is accepted, our manager will contact you";    ----   повертає повідомлення якщо к-ть товару в замовленні не перевищує к-ть товару в наявності
// }
// }

// Функція перевірки пароля
// function checkPassword(password) {      -----   оголошене правило перевірки пароля
//   const correctPassword = "jqueryismyjam";        -----     оголошено пароль
//   return password === correctPassword ? `Access granted` : `Access denied, wrong password!`;     -----  (password === correctPassword) - строге рівняння пароля, щоб збігались
// } ------(?) - оператор, (`Access granted`) - виводиться якщо паролі співпадають, (`Access denied, wrong password!`) - виводиться якщо паролі не співпадають

// Функція отримання інформації про передплату
// function getSubscriptionPrice(type) {
//   switch (type) {
//     case `starter`:
//       return "0";
//       break;
//     case `professional`:
//       return "20";
//       break;
//     case `organization`:
//       return "50";
//       break;
//     default:
//   return "Invalid subscription type!";
//       break;
// }
// }

// ======== Логічні оператори =========

// Функція перевірки чи входить число у проміжок
// function isNumberInRange(start, end, number) {
//   if (number >= start && number <= end) {
//     return true
//   } else {
//     return false;
//   }
// }
// Альтернативне і коротше рішення
// function isNumberInRange(start, end, number) {
//   return number >= start && number <= end;
// }
// isNumberInRange(10, 30, 17);
// isNumberInRange(10, 30, 5);
// isNumberInRange(20, 50, 24);
// isNumberInRange(20, 50, 76);

// Функція перевірки відповідності передплати (доступ до контенту)
// function checkAccess(subType) {
//   return subType === 'pro' || subType === 'vip';
// }

// Функція перемикання стану модального вікна
// function toggleModalVisibility(isVisible) {
//   return !isVisible;    ------ повертає протилежне значення, замість початкового true повертає false
// }

// =========  Методи рядків  ========

// Функція приймає рядок і повертає новий підрядок (його часткову копію).
// function getSubstring(string, length) {    -----   задана функція, string - речення, length - число символів які копіюються
//   return string.slice(0, length);     ---  повернення рядка, 0 - індекс від якого починається копіювання
// }

// Функція яка оголошує два параметри які потрібно привести у верхній або нижній регістри
// function normalizeInput(input, to) {     -----   оголошена функція
//   if (to === "upper") {     ---- параметр який відповідає значенню
//     return input.toUpperCase();   ---  приводить до верхнього регістру
//   } else if (to === "lower") {   ----- параметр який відповідає значенню
//     return input.toLowerCase();    ---- приводить до нижнього регістру
//   }
// }

// Функція приймає два параметри та повертає буль true або false - результат перевірки входження підрядка firstName у рядок fullName.
// function checkForName(fullName, firstName) {    ----  оголошення функції
//   const normalFullName = fullName.toLowerCase();    ----  приводимо значення у нижній регістр
//   const normalFirstName = firstName.toLowerCase();    ----  приводимо значення у нижній регістр
//   return normalFullName.includes(normalFirstName);    ---- повертаємо порівняння
// }

// Функція приймає два параметри:
//     fileName - рядок, що зберігає ім'я файлу з розширенням, наприклад, styles.css, hello.js
//  тощо.
//     ext - рядок, що зберігає розширення, наприклад, .css, .js тощо
// function checkFileExtension(fileName, ext) {   --- оголошення функції
//   if (fileName.endsWith(ext)) {    ----- оголошення функції виявлення збігу розширення
//     return 'File extension matches';   ---   повернення повідомлення при позитивному
//  результаті
//   } else {
//     return 'File extension does not match';   ---   повернення повідомлення при негативному
// результаті
//   }
// }

// Функція приймає один параметр
//     file - рядок з іменем файлу. Ім'я файлу може бути з розширенням, наприклад: styles.css, app.js або без, наприклад: styles, app.
// function getFileName(file) {   ----   оголошення функції
//   const pointFile = file.indexOf(".");   ---- перевіряємо чи є розширення яке починається з крапки
//   if (pointFile === -1) {   ----   оголошуємо функцію, якщо крапки немає
//     return file;    ----   повертаємо вихідну назву файла
//   }
//   return file.slice(0, pointFile);    ---   повертаємо назву файла без розширення
// }

// Функція, для того, щоб прибрати лишні пробіли, та записати два значення разом через крапку
// function createFileName(name, ext) {    ----   оголошення функції
//   return `${name.trim()}.${ext.trim()}`;   ----  повертаємо обидва значення без пробілів та разом через крапку
// }

//   =========  Цикли  ========

// Функція calculateTotal(number) приймає ціле число(параметр number).
// Доповни код функції так, щоб вона повертала суму всіх цілих чисел від одиниці
// до цього числа включно.Наприклад, якщо number дорівнює 3, то сума - це 1 + 2 + 3, тобто 6.
// function calculateTotal(number) {
//   let sum = 0;
//   let numeric = 1;
//   while (numeric <= number) {
//     sum += numeric; // Додаємо поточне число до суми
//     numeric++; // Збільшуємо лічильник на 1
//   }
//   return sum; // Повертаємо результат після завершення циклу
// }
// Давайте детально розберемо виправлену функцію calculateTotal(number):
// Завдання функції:
// Функція приймає ціле число number і повертає суму всіх цілих чисел від 1 до number включно. Наприклад:
//     Якщо number = 3, то результат: 1+2+3=61+2+3=6.
//     Якщо number = 5, то результат: 1+2+3+4+5=151+2+3+4+5=15.
// Виправлений код:
// function calculateTotal(number) {
//   let sum = 0; // Створюємо змінну для збереження підсумкової суми, початкове значення 0
//   let numeric = 1; // Створюємо змінну для поточного числа, з якого почнемо додавати
//   while (numeric <= number) { // Цикл працює, поки numeric менше або дорівнює number
//     sum += numeric;  // Додаємо значення numeric до суми (sum = sum + numeric)
//     numeric++;       // Збільшуємо numeric на 1, щоб перейти до наступного числа
//   }
//   return sum; // Повертаємо загальну суму після завершення циклу
// }
// Що означають змінні:
//     sum:
//         Це змінна для збереження загальної суми чисел.
//         Початкове значення 0, оскільки на початку ми ще нічого не додали.
//         В кожній ітерації ми додаємо до sum поточне значення numeric.
//     numeric:
//         Це змінна, яка представляє поточне число в ряду (починається з 1).
//         Збільшується на 1 після кожної ітерації циклу.
//     Цикл while (numeric <= number):
//         Працює, поки значення numeric не перевищить значення number.
//         На кожному кроці додає поточне значення numeric до sum.
//     return sum:
//         Повертає загальну суму після завершення всіх ітерацій циклу.
// Приклад виконання коду:
// Виклик функції:
// calculateTotal(3);
// Виконання по кроках:
//     Ініціалізація:
//         sum = 0
//         numeric = 1
//     Перша ітерація:
//         numeric = 1
//         Умова numeric <= number (1 <= 3) → true.
//         sum += numeric → 0+1=10+1=1.
//         numeric++ → numeric=2numeric=2.
//     Друга ітерація:
//         numeric = 2
//         Умова numeric <= number (2 <= 3) → true.
//         sum += numeric → 1+2=31+2=3.
//         numeric++ → numeric=3numeric=3.
//     Третя ітерація:
//         numeric = 3
//         Умова numeric <= number (3 <= 3) → true.
//         sum += numeric → 3+3=63+3=6.
//         numeric++ → numeric=4numeric=4.
//     Четверта ітерація:
//         numeric = 4
//         Умова numeric <= number (4 <= 3) → false.
//         Цикл завершується.
//     Повернення результату:
//         return sum → 66.
// Переваги такого підходу:
//     Простота: Код легко читається і зрозумілий.
//     Універсальність: Працює для будь-якого цілого числа number >= 1.
//     Ефективність: Використовує мінімальну кількість змінних і операцій.

// Функція calculateEvenTotal(number) приймає ціле число(параметр number).
//  Доповни код функції так, щоб вона повертала суму всіх парних цілих чисел від одиниці
//   до цього числа включно.Парні числа — це ті, що можна поділити на 2 без остачі
//     (як це зробити розглядалося у темі Арифметичні операції у модулі 1).Наприклад,
//     якщо number дорівнює 6, то сума - це 2 + 4 + 6, тобто 12.
// function calculateEvenTotal(number) {
//   let sum = 0; // Ініціалізуємо змінну для збереження суми
//   for (let i = 1; i <= number; i++) { // Цикл від 1 до number
//     if (i % 2 === 0) { // Перевіряємо, чи число парне
//       sum += i; // Додаємо парне число до суми
//     }
//   }
//   return sum; // Повертаємо підсумкову суму
// }
// Пояснення:
//     Ініціалізація:
//         Змінна sum = 0 використовується для збереження результату (суми парних чисел).
//         Цикл for починається з i = 1 і триває, поки i <= number.
//     Перевірка на парність:
//         Для перевірки, чи число є парним, використовуємо вираз i % 2 === 0.
//         Якщо число ділиться на 2 без остачі, то воно парне.
//     Додавання числа:
//         Якщо умова парності виконується, додаємо поточне значення i до змінної sum.
//     Повернення результату:
//         Після завершення циклу функція повертає значення sum, яке містить суму всіх парних чисел від 1 до number.
// Приклад виконання:
// Виклик функції:
// calculateEvenTotal(6);
// Виконання:
//     Ітерація 1: i = 1 → не парне, пропускаємо.
//     Ітерація 2: i = 2 → парне, sum = 0 + 2 = 2.
//     Ітерація 3: i = 3 → не парне, пропускаємо.
//     Ітерація 4: i = 4 → парне, sum = 2 + 4 = 6.
//     Ітерація 5: i = 5 → не парне, пропускаємо.
//     Ітерація 6: i = 6 → парне, sum = 6 + 6 = 12.
// Повертається результат: 12.

// Завдання
// Знайти перше число в діапазоні від start до end, яке ділиться на 5 без остачі.
// Рішення через for
// const start = 6;
// const end = 17;
// let number;
// for (let i = start; i <= end; i++) {  // Починаємо з start, перевіряємо до end включно
//   if (i % 5 === 0) {  // Якщо число ділиться на 5 без остачі
//     number = i;  // Зберігаємо це число в змінну number
//     break;  // Виходимо з циклу, бо знайшли потрібне число
//   }
// }
// console.log(number);  // Виводимо знайдене число
// Пояснення крок за кроком
//     Змінні start і end:
//         Ми задаємо початок (start) і кінець (end) діапазону.
//     Цикл for:
//         Ініціалізація: Починаємо перевірку з start (let i = start).
//         Умова циклу: Продовжуємо, поки i <= end.
//         Збільшення: Після кожної ітерації збільшуємо i на 1 (i++).
//     Умова if (i % 5 === 0):
//         На кожній ітерації перевіряємо, чи ділиться поточне значення i на 5 без остачі.
//         Якщо умова виконується, ми знайшли потрібне число:
//             Зберігаємо його у змінну number.
//             Використовуємо break, щоб вийти з циклу.
//     Результат:
//         Як тільки знайдено перше число, яке відповідає умові, цикл завершується.
//         Ми виводимо значення number.
// Приклад виконання
// Дано:
// const start = 6;
// const end = 17;
//     Ітерація 1: i = 6 → Не ділиться на 5 → Пропускаємо (i++).
//     Ітерація 2: i = 7 → Не ділиться на 5 → Пропускаємо (i++).
//     Ітерація 3: i = 8 → Не ділиться на 5 → Пропускаємо (i++).
//     Ітерація 4: i = 9 → Не ділиться на 5 → Пропускаємо (i++).
//     Ітерація 5: i = 10 → Ділиться на 5 → Зберігаємо number = 10 → Виконуємо break.
// Результат: 10.
// Інші приклади
//     Якщо:
// const start = 17;
// const end = 25;
// Процес:
//     i = 17, i = 18, i = 19 → Пропускаємо.
//     i = 20 → Ділиться на 5 → number = 20 → break. Результат: 20.
// Якщо:
//     const start = 2;
//     const end = 11;
//     Процес:
//         i = 2, i = 3, ..., i = 4 → Пропускаємо.
//         i = 5 → Ділиться на 5 → number = 5 → break. Результат: 5.
// Чому використовується break?
//     Без break цикл продовжував би перевіряти всі наступні числа, навіть після знаходження першого підходящого.
//     Це неефективно, адже нам потрібно лише перше число.
// =====  Порівняння з while
// const start = 6;
// const end = 17;
// let number = start;
// while (number <= end) {  // Поки number не перевищує end
//   if (number % 5 === 0) {  // Якщо number ділиться на 5 без остачі
//     break;  // Завершуємо цикл, тому що знайшли потрібне число
//   }
//   number++;  // Якщо умова не виконана, збільшуємо number на 1
// }
// console.log(number);  // Виводимо знайдене число
//     У while цикл вимагає більше ручного контролю (ініціалізація, інкремент, умови).
//     У for все це зручно зібрано в одному рядку, що робить його більш компактним та читабельним для цієї задачі.

// Функція findNumber(start, end, divisor) приймає три параметра, які є цілими числами.
// Доповни код функції таким чином, щоб вона:
//     повертала перше число у діапазоні від start до end включно, яке ділиться на divisor без остачі
//     не використовуй оператор break
// function findNumber(start, end, divisor) {
//   let number;
//   for (let i = start; i <= end; i++) {
//     if (i % divisor === 0) {
//       number = i;
//       return number;
//     }
//   }
// }
