// =======  Масиви  =======

// Функція getLastElementMeta(array) приймає один параметр array - масив довільних значень.
//  Доповни код функції таким чином, щоб вона повертала новий масив з двох елементів:
//     перший елемент - це індекс останнього елементу у масиві array
//     другий елемент - це значення останнього елементу у масиві array
// function getLastElementMeta(array) {
//     const lastIndex = array.length - 1; // Індекс останнього елемента
//     const lastValue = array[lastIndex]; // Значення останнього елемента
//     return [lastIndex, lastValue]; // Повернення нового масиву
// }
// Як це працює:
//     array.length - 1 отримує індекс останнього елемента.
//     array[lastIndex] отримує значення останнього елемента.
//     [lastIndex, lastValue] формує масив із цих двох значень.

// Функція getExtremeElements(array) приймає один параметр array - масив елементів
//  довільної довжини.Доповни код функції таким чином, щоб вона повертала масив з двох
// елементів - першого і останнього елементів параметра array.
// function getExtremeElements(array) {
//   const startElement = array[0]; // Перший елемент масиву
//   const endElement = array[array.length - 1]; // Останній елемент масиву
//   return [startElement, endElement]; // Масив з першого та останнього елемента
// }
// Пояснення:
//     array[0] — це перший елемент масиву.
//     array[array.length - 1] — це останній елемент масиву.
//     Повертається масив, що містить ці два елементи.

// Функція getLength(array) очікує один параметр array - масив довільних значень.
// Доповни код функції так, щоб вона перетворювала масив у рядок, без роздільників,
//     і повертала кількість символів в отриманому рядку.
// function getLength(array) {  ----    оголошення функції
//     const totalJoin = array.join(""); ----- перетворюємо масив в один рядок
//   return totalJoin.length;    ----   повертаємо к-ть символів в рядку
// }

// Сервісу гравірування прикрас потрібна функція, яка б автоматично рахувала ціну гравірування,
// залежно від кількості слів і ціни за слово.
// Оголошена функція calculateEngravingPrice(message, pricePerWord).
// Ця функція приймає першим параметром рядок, що складається зі слів,
//  розділених лише пробілами(параметр message) та другим параметром - число,
//  що містить ціну гравірування за одне слово(параметр pricePerWord).
// Доповни тіло функції так, щоб вона повертала загальну вартість гравірування усіх слів в рядку.
// function calculateEngravingPrice(message, pricePerWord) {
//   const wordsMessage = message.split(" ");     ----  розділяємо текст на окремі слова по пробілу
//   const lastMessage = wordsMessage.length;    -----  вираховуємо к-ть слів
//   return lastMessage * pricePerWord;          -----   виводимо к-ть слів помножену на ціну слова (сума замовлення)
// }

// Доповни код таким чином, щоб змінні містили часткові копії вихідного масиву fruits.
//     firstTwoEls - масив із перших двох елементів
//     nonExtremeEls - масив з усіх елементів, крім першого та останнього
//     lastThreeEls - масив із трьох останніх елементів
// const fruits = ["apple", "plum", "pear", "orange", "banana"];  ---  масив
// const firstTwoEls = fruits.slice(0, 2);    ----  повертає перший та другий елемент масиву
// const nonExtremeEls = fruits.slice(1, -1);   ----  повертає всі елементи окрім першого та останнього
// const lastThreeEls = fruits.slice(-3);    ----- повертає останні три елементи масиву

// Оголоси змінну allClients та доповни код таким чином, щоб її значенням було посилання на масив,
//     що складається з усіх елементів масивів oldClients і newClients.
// Спочатку мають іти елементи з масива oldClients, а потім з newClients.
// const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];  ----  старі клієнти
// const newClients = ["Peach", "Houston"];    -----   нові клієнти
// const allClients = oldClients.concat(newClients); ----- поєднаний масив з старих та нових клієнтів, спочатку старі

// Функція getSlice(array, value) приймає два параметра:
//     array - масив довільних елементів
//     value - значення елемента масиву для пошуку
// Доповни код функції getSlice(array, value) так, щоб вона виконувала пошук значення value у масиві array і повертала:
//     порожній масив, якщо в array немає елемента зі значенням value
//     підмасив, що починається з початку array і до елемента зі значенням value включно, якщо такий елемент є в array
// Ось чітке пояснення і рішення задачі:
// Завдання:
//     Знайти вказане значення value в масиві array.
//     Якщо значення value є в масиві:
//         Повернути підмасив, який починається з початку масиву і закінчується елементом value включно.
//     Якщо значення value немає:
//         Повернути порожній масив.
// Рішення:
// function getSlice(array, value) {
//   // Знайти індекс елемента зі значенням value у масиві
//   const index = array.indexOf(value);
//   // Якщо індекс дорівнює -1, значення value не знайдено
//   if (index === -1) {
//     return [];
//   }
//   // Повернути підмасив від початку масиву до знайденого індексу (включно)
//   return array.slice(0, index + 1);
// }
// Пояснення коду:
//     indexOf(value):
//         Повертає індекс першого входження value у масиві.
//         Якщо значення value немає в масиві, повертає -1.
//     Перевірка індексу:
//         Якщо index === -1, значення value немає у масиві, повертаємо порожній масив [].
//     slice(0, index + 1):
//         Метод slice(start, end) повертає частину масиву.
//         start = 0 — починаємо з початку масиву.
//         end = index + 1 — включаємо елемент зі значенням value.

// Функція createArrayOfNumbers(min, max) приймає два параметра:
//     min - ціле число, з якого починаються обчислення
//     max - ціле число, до якого включно триватимуть обчислення
// Доповни код функції createArrayOfNumbers(min, max) таким чином,
// щоб вона повертала масив усіх цілих чисел від значення min до max включно.
//  Назва змінної для масиву: Змінна, в якій зберігається масив, повинна мати
//  значення const або let, а не використовуватися без оголошення.Ви використовуєте sum
//   без явного оголошення.
//     Логіка return: Ви повертаєте значення масиву всередині циклу for після додавання
//     першого елемента.Це означає, що функція завершить виконання після першої ітерації.
// Виправлений код:
// function createArrayOfNumbers(min, max) {
//   const numbers = []; // Оголошення змінної для масиву
//   for (let i = min; i <= max; i++) {
//     numbers.push(i); // Додавання числа до масиву
//   }
//   return numbers; // Повертаємо масив після завершення циклу
// }
// Пояснення:
// const numbers = []: Змінну для зберігання масиву ми оголошуємо за допомогою const.
//     Це дозволяє уникнути помилок, пов'язаних з використанням неоголошених змінних.
//     Цикл for: Ми ітеруємо числа від min до max включно, додаючи кожне число до масиву
//     за допомогою push(i).
// return numbers: Масив повертається після завершення циклу, щоб включити всі числа
//      від min до max.

// Функція calculateTotalPrice(order) приймає один параметр order - масив чисел.
//  Доповни функцію так, щоб вона повертала загальну суму елементів з масиву order.
// Ось як виглядає правильне рішення задачі:
// function calculateTotalPrice(order) {
//   let total = 0; // Ініціалізуємо змінну для підсумку
//   for (let i = 0; i < order.length; i++) {
//     total += order[i]; // Додаємо кожен елемент масиву до загальної суми
//   }
//   return total; // Повертаємо підсумкову суму
// }
// Пояснення:
//     Ініціалізація змінної total: Ми створюємо змінну total і встановлюємо її початкове
//     значення в 0. Вона буде використовуватись для підрахунку загальної суми.
//     Цикл for:
//         Ми проходимося по всіх елементах масиву order за допомогою циклу for.
//         Початковий індекс i = 0, а закінчується цикл, коли i дорівнює довжині масиву.
//     Додавання елементів: На кожній ітерації додаємо поточний елемент масиву order[i]
//      до змінної total.
//     Повернення результату: Після завершення циклу функція повертає значення змінної total.

// Функція getEvenNumbers(start, end) має два параметри start та end, які є цілими числами.
//  Доповни код функції так, щоб вона повертала масив усіх парних чисел від start до end.
//  Якщо жодного парного числа немає, то масив має бути пустим.Парним вважається число,
//     яке ділиться на 2 без остачі(10 % 2 === 0).Використовуй цикл for.
// Ось як можна вирішити задачу:
// function getEvenNumbers(start, end) {
//   const evenNumbers = []; // Ініціалізуємо порожній масив для парних чисел
//   for (let i = start; i <= end; i++) { // Починаємо цикл з `start` до `end` включно
//     if (i % 2 === 0) { // Перевіряємо, чи число парне
//       evenNumbers.push(i); // Додаємо парне число до масиву
//     }
//   }
//   return evenNumbers; // Повертаємо масив з парними числами
// }
// Пояснення:
//     Ініціалізація масиву:
//         Створюємо порожній масив evenNumbers, в який будемо додавати знайдені парні числа.
//     Цикл for:
//         Починаємо цикл із числа start і виконуємо його до числа end включно.
//         На кожній ітерації перевіряємо, чи число i є парним, використовуючи умову i % 2 === 0 (число ділиться на 2 без остачі).
//     Додавання до масиву:
//         Якщо число парне, додаємо його до масиву evenNumbers за допомогою методу push().
//     Повернення результату:
//         Після завершення циклу повертаємо масив evenNumbers.

// Функція checkStorage(storage, item) приймає два параметри:
//     storage - масив рядків, що описує доступні товари на складі
//     item - рядок з назвою товара, наявність якого потрібно перевірити
// Доповни код функції таким чином, щоб вона перевіряла, чи присутній такий товар в масиві
//  storage і повертала:
//     рядок "<item> is available to order!", де item - це назва товара, якщо товар було знайдено
//     рядок "Sorry! We are out of stock!", якщо такого товара немає в масиві
// Зроби так, щоб пошук за ім'ям товару був незалежний від регістру,
// тобто наприклад "plum" і "pLuM" мають бути знайдені у масиві["apple", "plum", "pear"].
// function checkStorage(storage, item) {
//  const normalItem = item.toLowerCase();
//   if (storage.includes(normalItem)) {
//     return `${normalItem} is available to order!`;
//   }
//   return 'Sorry! We are out of stock!';
// }

// Перед розв'язанням цієї задачі варто зазначити, що таке спільні елементи. Спільними елементами
//  масивів називають ті елементи, які присутні у всіх масивах.
//   Наприклад, у двох масивах[1, 3, 5] і[0, 8, 5, 3] спільними будуть числа 3 і 5,
//   оскільки вони присутні в обох вхідних масивах.А числа 0, 1 і 8 присутні тільки в одному з
// масивів.
// Функція getCommonElements(array1, array2), приймає два масиви(array1 та array2) довільної
// довжини в якості параметрів.
// Доповни код функції:
//     Створи порожній масив для зберігання нового масиву.
//     Використай цикл for для ітерації кожного елемента у array1.
//     У тілі циклу перевір, чи поточний елемент існує у array2 за допомогою методу includes.
//     Якщо він існує, то додай елемент до нового масиву.
//     Поверни наповнений масив спільних елементів як результат роботи функції.
// Ось як правильно вирішити задачу з детальним поясненням:
// Код:
// function getCommonElements(array1, array2) {
//   const commonElements = []; // Створюємо порожній масив для зберігання спільних елементів

//   for (let element of array1) { // Перебираємо кожен елемент масиву array1
//     if (array2.includes(element)) { // Перевіряємо, чи є поточний елемент у array2
//       commonElements.push(element); // Якщо є, додаємо його до масиву commonElements
//     }
//   }
//   return commonElements; // Повертаємо масив спільних елементів
// }
// Пояснення:
//     Створення порожнього масиву:
//         Масив commonElements створений для зберігання елементів, які є спільними між array1 і
// array2.
//     Цикл for:
//         Цикл for проходить по кожному елементу масиву array1.
//         Замість класичного for із індексами ми використовуємо синтаксис
// for (let element of array1), що дозволяє безпосередньо отримувати значення елементів.
//     Перевірка наявності елемента:
//         Для кожного елемента масиву array1 перевіряємо, чи існує такий самий елемент у масиві
//          array2 за допомогою методу includes.
//         Метод includes повертає true, якщо елемент є в масиві, і false, якщо його немає.
//     Додавання до нового масиву:
//         Якщо елемент з array1 знайдено в array2, ми додаємо його до масиву commonElements
//          за допомогою методу push.
//     Повернення результату:
//         Після завершення циклу повертаємо масив commonElements, який містить усі спільні
// елементи.

// Доповни код функції calculateTotalPrice(order) так, щоб вона повертала загальну суму чисел в
//  масиві order.Використай цикл for...of для перебору масиву.
//  Оголошена функція calculateTotalPrice(order)
// Виклик функції calculateTotalPrice([12, 85, 37, 4]) повертає 138
// Виклик функції calculateTotalPrice([164, 48, 291]) повертає 503
// Ось рішення задачі з використанням циклу for...of:
// function calculateTotalPrice(order) {
//   let total = 0; // Ініціалізуємо змінну для зберігання суми
//   for (const item of order) { // Перебираємо кожен елемент масиву order
//     total += item; // Додаємо поточний елемент до total
//   }
//   return total; // Повертаємо загальну суму
// }
// Пояснення:
//     Змінна total:
//         Змінна total створена для зберігання проміжної суми чисел. Вона ініціалізується значенням 0.
//     Цикл for...of:
//         Цикл for...of використовується для перебору кожного елемента масиву order.
//         На кожній ітерації значення елемента записується у змінну item.
//     Додавання до total:
//         На кожній ітерації значення елемента item додається до змінної total.
//     Повернення результату:
//         Після завершення циклу функція повертає загальну суму total.

// Умова задачі:
//     Функція createReversedArray має приймати довільну кількість аргументів.
//     Потрібно повернути масив усіх аргументів у зворотному порядку.
//     Якщо аргументів немає, функція має повернути порожній масив.
// Рішення 1: Використання методу toReversed()
// Код:
// function createReversedArray(...args) {
//   return args.toReversed();
// }
// Як це працює:
//     Оператор ...args:
//         Використовується оператор залишкових параметрів(...), який збирає всі передані
//         функції аргументи у масив.
//   Наприклад, якщо викликати createReversedArray(1, 2, 3), змінна args буде рівна [1, 2, 3].
//     Метод toReversed():
// toReversed() створює нову копію масиву, де всі елементи розташовані у зворотному порядку.
//     Це сучасний метод JavaScript, який не змінює вихідний масив.
//         Наприклад:
//         const array = [1, 2, 3];
//         const reversedArray = array.toReversed();
//         console.log(reversedArray); // [3, 2, 1]
//         console.log(array); // [1, 2, 3] (оригінал не змінюється)
//     Повернення результату:
//         Функція повертає результат виконання args.toReversed().
// Приклад роботи:
// console.log(createReversedArray(1, 2, 3)); // [3, 2, 1]
// console.log(createReversedArray('a', 'b', 'c')); // ['c', 'b', 'a']
// console.log(createReversedArray()); // []
//              Рішення 2: Використання циклу for
// Код:
// function createReversedArray(...args) {
//   const reversedArray = [];
//   for (let i = args.length - 1; i >= 0; i--) {
//     reversedArray.push(args[i]);
//   }
//   return reversedArray;
// }
// Як це працює:
//     Оператор ...args:
//         Як і в першому рішенні, ...args збирає всі передані аргументи у масив.
//     Створення порожнього масиву:
//         Змінна reversedArray створюється для зберігання нового масиву у зворотному порядку.
//     Цикл for:
//         Ітерація починається з останнього індексу масиву args(args.length - 1) і триває до
//          першого елемента(i >= 0).
//         На кожній ітерації до масиву reversedArray додається поточний елемент масиву args
//         за допомогою методу.push().
//     Повернення результату:
//         Після завершення циклу повертається новий масив reversedArray.
// Приклад роботи:
// console.log(createReversedArray(1, 2, 3)); // [3, 2, 1]
// console.log(createReversedArray(10, 20, 30, 40)); // [40, 30, 20, 10]
// console.log(createReversedArray()); // []
// Додаткове пояснення:
// Чому використовують ...args?
//     Оператор залишкових параметрів (...) дозволяє зібрати всі передані аргументи у масив. Це зручно, оскільки функція може приймати будь-яку кількість аргументів:
// createReversedArray(1, 2, 3); // args = [1, 2, 3]
// createReversedArray('a', 'b'); // args = ['a', 'b']

// Функція calculateTax(amount, taxRate) оголошує два параметри:
//     amount - число, сума від якої потрібно обчислити податок. Обов'язковий параметр.
//     taxRate - число, податкова ставка. Необов'язковий параметр. За замовчуванням його
//     значення має бути 0.2.
// Доповни код функції так, щоб вона повертала суму податку - результат множення суми на
// податкову ставку.
// function calculateTax(amount, taxRate = 0.2) {
//   return amount * taxRate;
// }
// Що відбувається в коді:
//     Параметру taxRate надано значення за замовчуванням 0.2, яке буде використовуватися,
//     якщо значення для нього не передане при виклику функції.
//     Функція повертає суму податку, яка обчислюється множенням amount на taxRate.

// ========  Home Work  ========

// ========  Задача №1  ========
// Перш, ніж розв’язувати задачу, давай визначимося із новим терміном!
// Термін slug — це зрозумілий людині унікальний ідентифікатор, який використовується у веб
//  розробці для створення читабельних URL-адрес.
// Наприклад, замість того, щоб користувач побачив в адресному рядку
// mysite.com/posts/1q8fh74tx, можна зробити slug із назви статті.
//  У результаті адреса буде приємнішою для сприйняття: mysite.com/posts/arrays-for-beginners.

// Slug — це завжди рядок у нижньому регістрі, слова якого розділені тире.
// З цим розібралися? А тепер давай нарешті виконувати задачу!

// Напиши функцію slugify(title), яка приймає заголовок статті, параметр title і повертає slug,
//  створений із цього рядка.
//     Значенням параметра title будуть рядки, слова яких розділені лише пробілами.
//     Усі символи slug повинні бути в нижньому регістрі.
//     Усі слова slug повинні бути розділені тире.

// console.log(slugify("Arrays for beginners")); // "arrays-for-beginners"
// console.log(slugify("English for developer")); // "english-for-developer"
// console.log(slugify("Ten secrets of JavaScript")); // "ten-secrets-of-javascript"
// console.log(slugify("How to become a JUNIOR developer in TWO WEEKS")); // "how-to-become-a-junior-developer-in-two-weeks"

// ========  Задача №2  ========
// Напиши функцію під назвою makeArray, яка приймає три параметри: firstArray (масив),
// secondArray (масив) і maxLength (число). Функція повинна створювати новий масив,
//  який містить усі елементи з firstArray, а потім усі елементи з secondArray.
//     Якщо кількість елементів у новому масиві перевищує maxLength, функція повинна
// повернути копію масиву з довжиною maxLength елементів.
//     В іншому випадку функція повинна повернути весь новий масив.
// Візьми код нижче і встав після оголошення своєї функції для перевірки коректності
// її роботи. У консоль будуть виведені результати її роботи.

// console.log(makeArray(["Mango", "Poly"], ["Ajax", "Chelsea"], 3)); // ["Mango", "Poly", "Ajax"]
// console.log(makeArray(["Mango", "Poly", "Houston"], ["Ajax", "Chelsea"], 4)); // ["Mango", "Poly", "Houston", "Ajax"]
// console.log(makeArray(["Mango"], ["Ajax", "Chelsea", "Poly", "Houston"], 3)); // ["Mango", "Ajax", "Chelsea"]
// console.log(makeArray(["Earth", "Jupiter"], ["Neptune", "Uranus"], 2)); // ["Earth", "Jupiter"]
// console.log(makeArray(["Earth", "Jupiter"], ["Neptune", "Uranus"], 4)); // ["Earth", "Jupiter", "Neptune", "Uranus"]
// console.log(makeArray(["Earth", "Jupiter"], ["Neptune", "Uranus", "Venus"], 0)); // []

// ========  Задача №3  ========
// Напиши функцію filterArray(numbers, value), яка приймає масив чисел (numbers)
// та значення (value) як параметри. Функція повинна повертати новий масив лише тих чисел
//  із масиву numbers, які більші за значення value.
// Усередині функції:
//     Створи порожній масив, у який будеш додавати підходящі числа.
//     Використай цикл для ітерації кожного елемента масиву numbers.
//     Використовуй умовний оператор if усередині циклу для перевірки кожного елемента и
// додавання до свого масиву.
//     Поверни свій новий масив з підходящими числами як результат.

// console.log(filterArray([1, 2, 3, 4, 5], 3)); // [4, 5]
// console.log(filterArray([1, 2, 3, 4, 5], 4)); // [5]
// console.log(filterArray([1, 2, 3, 4, 5], 5)); // []
// console.log(filterArray([12, 24, 8, 41, 76], 38)); // [41, 76]
// console.log(filterArray([12, 24, 8, 41, 76], 20)); // [24, 41, 76]
